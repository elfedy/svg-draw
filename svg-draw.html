<html>
	<head>
		<meta charset="utf-8"/>
	</head>

	<body>
		<main>
			<div class="canvas-container">
				<svg version="1.1" 
					baseProfile="full" 
					width="500" 
					height="500"
					xmlns="http://www.w3.org/2000/svg"
					class="js-svg"
					>
					<rect height="100%" width="100%" fill="#fff"/>
				</svg>
			</div>
			<div class="controls">
				<div class="controls__grid">
					<button class="elem-button js-insert-rect" data-item="action">
						<svg height="30" width="30">
							<rect x="5" y="5" height="20" width="20" fill="transparent" stroke="black" stroke-width="1" />
						</svg>
					</button>

					<button class="elem-button js-insert-text" data-item="action">
						A
					</button>

					<label>Grid Size</label>
					<div class="controls__group">
						<label>x</label>
						<input class="js-size-x" type="number" min="0" max="1000" step="50" value="500"/>
					</div>

					<div class="controls__group">
						<label>y</label>
						<input class="js-size-y" type="number" min="0" max="1000" step="50" value="500" />
					</div>
				</div>
			</div>
		</main>
	</body>

	<script>
		// Main canvas and definitions

		let svg = document.querySelector('.js-svg');
		let svgns = "http://www.w3.org/2000/svg";

		let nonTextKeys = ["Alt", "Dead", "Meta", "Shift"]

		// Controls

		let xSize = document.querySelector('.js-size-x');
		let ySize = document.querySelector('.js-size-y');
		let insertRect = document.querySelector('.js-insert-rect');
		let insertText = document.querySelector('.js-insert-text');

		/*
		* GLOBAL STATE 
		*/

		let currentElement = null;
		let movementInitCoords = null

		// movement
		let isMovingElement = false;

		// text
		let textAction = null;

		// resize
		let isResizingDown = false
		let isResizingUp = false
		let isResizingRight = false
		let isResizingLeft = false

		// Event listeners for controls

		document.body.addEventListener('click', handleUserClick);
		document.body.addEventListener('mousemove', handleUserMousemove);
		document.body.addEventListener('mouseup', handleUserMouseup);
		document.body.addEventListener('keydown', handleUserKeydown);

		xSize.addEventListener('change', (e) => svg.setAttribute('width', xSize.value));
		ySize.addEventListener('change', (e) => svg.setAttribute('height', ySize.value));
		insertRect.addEventListener('click', insertSquare);
		insertText.addEventListener('click', insertTextElement);

		// Insert elements

		function insertSquare() {
			let rect = document.createElementNS(svgns, 'rect');
			rect.setAttribute('height', '100');
			rect.setAttribute('width', '100');
			rect.setAttribute('x', '100');
			rect.setAttribute('y', '100');
			rect.setAttribute('fill', 'transparent');
			rect.setAttribute('stroke', 'black');
			rect.setAttribute('stroke-width', '1');
			rect.setAttribute('data-item', 'element');
			rect.class = 'svg-rect';


			svg.appendChild(rect);
		}

		function insertTextElement() {
			let text = document.createElementNS(svgns, 'text');
			text.setAttribute('x', '100');
			text.setAttribute('y', '100');
			text.textContent  = 'Enter text';
			currentElement = text;
			textAction = 'initialInsert';
			svg.appendChild(text);
			console.log(currentElement);
		}

		// Event handlers

		function handleUserKeydown(e) {
			if(currentElement !== null) {
				switch(textAction) {
					case "initialInsert":
						console.log(e);
						if(!nonTextKeys.includes(e.key)) {
							e.preventDefault();
							currentElement.textContent = addKeyInput("", e.key);
							textAction = "inserting";
						}
						break;
					case "inserting":
						if(!nonTextKeys.includes(e.key)) {
							e.preventDefault();
							let currentText = currentElement.textContent;
							let newText = addKeyInput(currentText, e.key);
							currentElement.textContent = newText;
						}
						break;
					default:
						if((e.keyCode === 8 || e.keyCode === 46)) {
							e.preventDefault();
							removeElement(currentElement);
							currentElement = null;
							placeSelectBox();
						}
				}
			}
		}

		function handleUserClick(e) {
			let itemType = e.target.getAttribute('data-item') || null;
			switch(itemType) {
				case 'element':
					handleElementClick(e.target);
					break;
				
				case 'selector':
					break;

				case 'resize':
					break;

				case 'action':
					break;

				default:
					// Deselect if target is not an item
					currentElement = null;
					placeSelectBox();
			}
		}

		function handleUserMousemove(e) {
			// Move element
			if(currentElement && isMovingElement) {
				movementInitCoords = movementInitCoords || {
					clientX: e.clientX, 
					clientY: e.clientY,
					elementX: parseInt(currentElement.getAttribute('x')),
					elementY: parseInt(currentElement.getAttribute('y')),
				};


				let diff = {
					x: e.clientX - movementInitCoords.clientX,
					y: e.clientY - movementInitCoords.clientY,
				}

				// Get new x/y values
				let borderWidth = parseInt(currentElement.getAttribute('stroke-width'));
				let minX = 0 + borderWidth;
				let maxX = parseInt(svg.getAttribute('width')) - borderWidth - parseInt(currentElement.getAttribute('width'));
				let minY = 0;// + borderWidth;
				let maxY = parseInt(svg.getAttribute('height')) - parseInt(currentElement.getAttribute('height')) - borderWidth;

				let targetX = movementInitCoords.elementX + diff.x;
				let newX = Math.min(maxX, Math.max(minX, targetX));
				let targetY = movementInitCoords.elementY + diff.y;
				let newY = Math.min(maxY, Math.max(minY, targetY));

				// Set new position
				currentElement.setAttribute('x', newX);
				currentElement.setAttribute('y', newY);

				placeSelectBox();
			}

			// Resize Vertically
			if(currentElement && isResizingUp) {
				movementInitCoords = movementInitCoords || {
					clientY: e.clientY,
					elementY: parseInt(currentElement.getAttribute('y')),
					elementHeight: parseInt(currentElement.getAttribute('height')),
				};

				let diff = {
					y: movementInitCoords.clientY - e.clientY,
				};

				// Set new height value
				let borderWidth = parseInt(currentElement.getAttribute('stroke-width'));
				let targetHeight = movementInitCoords.elementHeight + diff.y;
				let maxHeight;
				let minHeight = 1;
				let newHeight;

				if(targetHeight >= 0) {
					// upwards resize (move y up and make larger)
					let targetY = movementInitCoords.elementY - diff.y
					if(targetY >= 0) {
						currentElement.setAttribute('y', targetY);
						currentElement.setAttribute('height', targetHeight);
					}
				} else {
					// downwards resize (make element larger keeping y)
					maxHeight = parseInt(svg.getAttribute('height')) - parseInt(currentElement.getAttribute('y')) - borderWidth;
					newHeight = Math.min(maxHeight, Math.max(minHeight, -targetHeight));
					currentElement.setAttribute('height', newHeight);
				}
				placeSelectBox();
			}

			if(currentElement && isResizingDown) {
				movementInitCoords = movementInitCoords || {
					clientY: e.clientY,
					elementY: parseInt(currentElement.getAttribute('y')),
					elementHeight: parseInt(currentElement.getAttribute('height')),
				};

				let diff = {
					y: e.clientY - movementInitCoords.clientY,
				};

				// Set new height value
				let borderWidth = parseInt(currentElement.getAttribute('stroke-width'));
				let targetHeight = movementInitCoords.elementHeight + diff.y;
				let maxHeight;
				let minHeight = 1;
				let newHeight;

				if(targetHeight >= 0) {
					// downwards resize (make element larger keeping y)
					maxHeight = parseInt(svg.getAttribute('height')) - parseInt(currentElement.getAttribute('y')) - borderWidth;
					newHeight = Math.min(maxHeight, Math.max(minHeight, targetHeight));
					currentElement.setAttribute('height', newHeight);
				} else {
					// upwards resize (move y up and make larger)
					let targetY = movementInitCoords.elementY + targetHeight
					if(targetY >= 0) {
						currentElement.setAttribute('y', targetY);
						currentElement.setAttribute('height', -targetHeight);
					}
				}

				placeSelectBox();
			}

			if(currentElement && isResizingRight) {
				movementInitCoords = movementInitCoords || {
					clientX: e.clientX,
					elementX: parseInt(currentElement.getAttribute('x')),
					elementWidth: parseInt(currentElement.getAttribute('width')),
				};

				let diff = {
					x: e.clientX - movementInitCoords.clientX,
				};

				// Set new width value
				let borderWidth = parseInt(currentElement.getAttribute('stroke-width'));
				let targetWidth = movementInitCoords.elementWidth + diff.x;
				let maxWidth;
				let minWidth = 1;
				let newWidth;

				if(targetWidth >= 0) {
					// right resize (make element larger keeping x)
					maxWidth = parseInt(svg.getAttribute('width')) - parseInt(currentElement.getAttribute('x')) - borderWidth;
					newWidth = Math.min(maxWidth, Math.max(minWidth, targetWidth));
					currentElement.setAttribute('width', newWidth);
				} else {
					// left resize (move x left and make larger)
					let targetX = movementInitCoords.elementX + targetWidth
					// Ignore transform if implies going outside the canvass
					if(targetX >= 0) {
						currentElement.setAttribute('x', targetX);
						currentElement.setAttribute('width', -targetWidth);
					}
				}

				placeSelectBox();
			}

			if(currentElement && isResizingLeft) {
				movementInitCoords = movementInitCoords || {
					clientX: e.clientX,
					elementX: parseInt(currentElement.getAttribute('x')),
					elementWidth: parseInt(currentElement.getAttribute('width')),
				};

				let diff = {
					x: movementInitCoords.clientX - e.clientX,
				};

				// Set new width value
				let borderWidth = parseInt(currentElement.getAttribute('stroke-width'));
				let targetWidth = movementInitCoords.elementWidth + diff.x;
				let maxWidth;
				let minWidth = 1;
				let newWidth;

				if(targetWidth >= 0) {
					// left resize (move x left and make larger)
					let targetX = movementInitCoords.elementX - diff.x;
					// Ignore transform if implies going outside the canvass
					if(targetX >= 0) {
						currentElement.setAttribute('x', targetX);
						currentElement.setAttribute('width', Math.max(targetWidth, minWidth));
					}
				} else {
					// right resize (make element larger keeping x)
					maxWidth = parseInt(svg.getAttribute('width')) - parseInt(currentElement.getAttribute('x')) - borderWidth;
					newWidth = Math.min(maxWidth, Math.max(minWidth, -targetWidth));
					currentElement.setAttribute('width', newWidth);
				}

				placeSelectBox();
			}
		}

		function handleElementClick(element) {
			selectElement(element);	
		}

		function handleElementMousedown(e) {
			let itemType = e.target.getAttribute('data-item') || null;

			if(itemType === 'selector') {
				isMovingElement = true;
			}

			if(itemType === 'resize') {
				let resizeDirection = e.target.getAttribute('data-location') || null;
				if(resizeDirection === "down") {
					isResizingDown = true;
				}

				if(resizeDirection === "up") {
					isResizingUp = true;
				}

				if(resizeDirection === "right") {
					isResizingRight = true;
				}

				if(resizeDirection === "left") {
					isResizingLeft = true;
				}
			}
		}

		function handleUserMouseup(e) {
			// Reset all mousemove related state
			isMovingElement = false;
			movementInitCoords = null;
			isResizingDown = false;
			isResizingUp = false;
		  isResizingRight = false;
		  isResizingLeft = false;
		}

		// Actions

		function selectElement(element) {
			// Set current element
			currentElement = element;
			placeSelectBox();
		}

		function placeSelectBox() {
			if(currentElement) {
				// Get dimensions
				let padding = 5;
				let dimensions = currentElement.getBoundingClientRect();
				let boxX = dimensions.x - padding / 2;
				let boxY = dimensions.y - padding / 2;
				let boxWidth = dimensions.width + padding;
				let boxHeight = dimensions.height + padding;

				// resize square dims
				let resizeLength = 10;
				let resizeDims = {
					up: {
						x: boxWidth / 2 - resizeLength / 2,
						y: - resizeLength / 2,
					},
					down: {
						x: boxWidth / 2 - resizeLength / 2,
						y: boxHeight - resizeLength / 2,
					},
					left: {
						x: -resizeLength / 2,
						y: boxHeight / 2 - resizeLength / 2,
					},
					right: {
						x: boxWidth - resizeLength / 2,
						y: boxHeight / 2 - resizeLength / 2,
					},
				}


				// handle select box style
				let selectBox = document.querySelector('div[data-item="selector"]') || null;
				let selectBoxFound = selectBox ? true : false;
				selectBox = selectBox || document.createElement('div');
				selectBox.style = `
					width: ${boxWidth}px;
					height: ${boxHeight}px;
					border: 1px solid #0a84ff;
					background-color: transparent;
					box-sizing: border-box;
					position: absolute;
					z-index: 10;
					left: ${boxX}px;
					top: ${boxY}px;
				`

				// handle resize rectangle style (Store in Array in case I need to insert them)
				let rectangleSelectors = 
					['up', 'down', 'left', 'right'].map(function(location) {
						let item = document.querySelector(`div[data-location="${location}"]`) || createResizeSquare(location);
						let cursor = ['up', 'down'].includes(location) ? 'ns-resize' : 'ew-resize';

						item.style = `
							width: ${resizeLength}px;
							height: ${resizeLength}px;
							border: 1px solid #000;
							background-color: #fff;
							box-sizing: border-box;
							cursor: ${cursor};
							position: absolute;
							z-index: 20;
							left: ${resizeDims[location].x}px;
							top: ${resizeDims[location].y}px;
						`

						return item
					})


				// init select box if not found
				if(!selectBoxFound) {
					selectBox.setAttribute('data-item', 'selector');
					selectBox.addEventListener('mousedown', handleElementMousedown);
					rectangleSelectors.forEach(function(rect) {
						selectBox.appendChild(rect);
					})
					document.body.appendChild(selectBox);
				}
			} else {
				// Delete select box if found
				removeSelectBox()
			}
		}

		// Create elements
		function createResizeSquare(location) {
			let square = document.createElement('div');
			square.setAttribute('data-item', `resize`);
			square.setAttribute('data-location', `${location}`);
			
			return square;
		}

		// Helpers
		function removeElement(element) {
			if(element) {
				element.parentNode.removeChild(element);
			}
		}

		function removeSelectBox() {
			let selectBox = document.querySelector('div[data-item="selector"]') || null;
			removeElement(selectBox);
		}

		function addKeyInput(currentText, newInput) {
			if(newInput == "Backspace") {
				return(currentText.length == 0 ? "" : currentText.slice(0, -1))
			} else {
				return(currentText + newInput)
			}
		}

		// Debugging

		function logElementPosition(element, label) {
			let dimensions = element.getBoundingClientRect();
		}
	</script>

	<style>
		body {
			margin: 0;
			padding: 0;
			height: 100%;
			width: 100%;
		}

		main {
			height: 100vh;
			width: 100%;
			background-color: #eaeaea;
		}

		.canvas-container {
			position: absolute;
			top: 50px;
			left: 50px;
		}

		.controls {
			position: absolute;
			top: 50px;
			left: 1100px;
			display: flex;
			flex-direction: column;
			background-color: #fff;
			padding: 20px;
		}

		.controls__group {
			input {
				width: 50%;
			}
		}

		.elem-button {
			display: block;
			background-color: transparent;
			border: none;
			outline: none;
			cursor: pointer;
		}
	</style>
</html>
